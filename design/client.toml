
[SPC-client]
partof = "REQ-client"
text = '''
The client will be a 2d graphical interface written in Rust using the piston
library.

For the time being the server should be a single data structure nested inside
of the client.

Entities will not exist as a single data structure, but will be an abstract
concept that binds multiple data structures together conceptually.

The exact layout of data in the client (excluding the server) is described in
[[SPC-client-data]].

The client shall render the objects associated with the `display`
snapshot, and draw paths associated with the `planned` timeline.

User input shall control the following events:
- Start simulating
- Stop simulating
- Return simulation to `recent`
- Return simulation to `init`
- Select a unit
- Add a move command to unit's current plan
- Add a kill command to unit's current plan
- Add a command to wait some amount of time??
- Remove a command from unit's current plan
- Submit current plan to server

Submitting current plan to server is a bit involved.
Ideally a length in time would be taken as input, that part of the plans would
be submitted, and the server will either respond with success, failure, or
interruption.
When submitted, the client shall render results between old 'recent' time up
until new 'recent' time.
This will also allow it to regenerate the new recent snapshot :o
Additionally the plan will have any successful commands removed from the front.


"Start simulating" actually means start playing the `planned` timeline, which
is calculated in advance.

Caulculating the timeline has two steps, the first is to find the path
associated with each command sequence.
It is unlikely that any commands will generate paths dynamically, since smart
paths so often rely on foresight about what the opponent _will_ do, not what
they have done already.
As a result, path information can be generated without actually running a
simulation.
Timing of actual events on the other hand, must be generated in proper
lock-step between all the units at once.
This means creating a snapshot, and using it to calculate the order that units
will fulfill their commands, as well as whether commands will succeed, and
whether units will die. The snapshot will walk forward as all of the
command/path sequences are iterated through, until eventually all commands have
been expressed in the simulation, or all units with remaining commands have
died.
'''

[SPC-client-data]
text = '''
Entity state should simply be the fields associated with a unit as described in
[[REQ-unit]].
The "dead" state should simply be weapon_use == ~0

A data structure should be defined, called a "snapshot", which contains all of
the entity states of all of the units at a particular time.

Another data structure, a "timeline" should exist, which contains the entity
state sequence of one or all entities.

Another data structure, a "command" enum, should exist which contains the info
associated with steps in the user's plans.
A Vec of these shall exist in the client, called plan.

The client will then be three snapshots, and a pair of timelines.
One snapshot, called init, will represent the inital state of the game.
Another, called recent, will represent the state last confirmed by the server.
The last will be called display, and will be at an arbitrary time allowing the
client to keep track of any state of the simulation, available for display.
The two timelines will be called confirmed, and planned.
Confirmed will be written to as the server accepts plans and responds with
outcomes.
Planned will continue from the `recent` snapshot, and will be the sequence of
events generated by the commands listed in `plan`.
This will need to be edited a lot, not clear whether it should be regenerated
or iterated in parallel to the command list.
'''
