
[SPC-client]
partof = "REQ-client"
text = '''
The client will be a 2d graphical interface written in Rust using the piston
library.

For the time being the server should be a single data structure nested inside
of the client.

Entities will not exist as a single data structure, but will be an abstract
concept that binds multiple data structures together conceptually.

The exact layout of data in the client (excluding the server) is described in
[[SPC-client-data]].

The client shall render the objects associated with the `display`
snapshot, and draw paths associated with the `planned` timeline.

User input shall control the following events:
- Start simulating
- Stop simulating
- Return simulation to `recent`
- Return simulation to `init`
- Select a unit
- Add a move command to unit's current plan
- Add a kill command to unit's current plan
- Add a command to wait some amount of time??
- Remove a command from unit's current plan
- Submit current plan to server

Submitting current plan to server is a bit involved.
Ideally a length in time would be taken as input, that part of the plans would
be submitted, and the server will either respond with success, failure, or
interruption.
When submitted, the client shall render results between old 'recent' time up
until new 'recent' time.
This will also allow it to regenerate the new recent snapshot :o
Additionally the plan will have any successful commands removed from the front.


"Start simulating" actually means start playing the `planned` timeline, which
is calculated in advance.
'''

[SPC-client-gen_planned]
text = '''
Caulculating the timeline has two steps, the first is to find the path
associated with each command sequence.

It is unlikely that any commands will generate paths dynamically, since smart
paths so often rely on foresight about what the opponent _will_ do, not what
they have done already.
As a result, path information can be generated without actually running a
simulation.

Timing of actual events on the other hand, must be generated in proper
lock-step between all the units at once.
This means copying the current snapshot, as well as all currently run commands,
and simulating the process of submitting each command (from the path
information) to the server, one by one, until all commands have been submitted.

Submitting a command has two parts:
1. client converts command into a desired state transition
2. server resolves conflicts with other state transitions
step 2 only applies to weapon usage/item interaction, not to movement.

When converting a command into state transitions, it is worth noting that the
completion of one command, and the initiation of the next command, take place
in a single state transition.

All external effects should be inferable from autonomous state changes.
When a command has an effect on another entity, it creates an additional state
transition.
This transition shall be applied over the top of any autonomous state
transitions that happen at the same time.
When the server applies these changes it shall check to see if the client has
already anticipated the change, and only if it hasn't will the server apply the
change and then notify the client of the change.
Finally some actions must terminate themselves, and if the weapon_action field
of a unit is not explicitly changed or reset at the expected time, then the
server will treat the reset as an external consequence of the action.

The actual algorithm will therefore be to iterate on the following sequence of
steops:
- see which command will end or have a side effect soonest
 - if multiple commands end at the same time, side effects must be applied
   afterward.
 - if multiple commands have effects, all effects are applied trade-style
- roll the snapshot forward to this time
- combine the current and next command into a state transition
- write the state transition to the timeline
- write the next command to the current commands, along with predicted end time

Eventually all units will either die or run out of commands, at which point all
current_commands will be None, and all command lists will be empty.
At this point the simulation is done.
'''

[SPC-client-data]
text = '''
Entity state should simply be the fields associated with a unit as described in
[[REQ-unit]].
The "dead" state should simply be weapon_use == ~0

A data structure should be defined, called a "snapshot", which contains all of
the entity states of all of the units at a particular time.

Another data structure, a "timeline" should exist, which contains the entity
state sequence of one or all entities.

Another data structure, a "command" enum, should exist which contains the info
associated with steps in the user's plans.
A Vec of these shall exist in the client, called plan.

The client will then be three snapshots, and a pair of timelines.
One snapshot, called init, will represent the inital state of the game.
Another, called recent, will represent the state last confirmed by the server.
The last will be called display, and will be at an arbitrary time allowing the
client to keep track of any state of the simulation, available for display.
The two timelines will be called confirmed, and planned.
Confirmed will be written to as the server accepts plans and responds with
outcomes.
Planned will continue from the `recent` snapshot, and will be the sequence of
events generated by the commands listed in `plan`.
This will need to be edited a lot, not clear whether it should be regenerated
or iterated in parallel to the command list.
'''
